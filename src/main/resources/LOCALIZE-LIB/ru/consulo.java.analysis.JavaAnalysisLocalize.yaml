0.field.is.always.initialized.not.null:
    text: '@{0} поле всегда инициализируется как не-null'
access.can.be.0:
    text: Доступ может быть {0}
access.to.field.code.ref.code.outside.of.declared.guards.loc:
    text: 'Доступ к полю <code>#ref</code> вне объявленных ограничений #loc'
add.explicit.type.arguments:
    text: Добавить явные аргументы типа
annotate.as.safevarargs:
    text: Добавить аннотацию @SafeVarargs
annotate.overridden.methods.parameters:
    text: Добавить аннотации «@{0}» к параметрам переопределенных методов
annotate.overridden.methods.parameters.family.name:
    text: Добавить аннотации к параметрам переопределенных методов
anonymous.ref.loc.can.be.replaced.with.0:
    text: 'Анонимный #ref #loc может быть заменён на {0}'
anonymous.ref.loc.can.be.replaced.with.lambda:
    text: 'Анонимный #ref #loc может быть заменён на лямбда-выражение'
arguments.count.mismatch:
    text: Ожидалось {0} аргументов, но найдено {1}
assigning.a.collection.of.nullable.elements:
    text: Присваивание коллекции nullable-элементов коллекции не-null элементов
call.to.method.code.ref.code.outside.of.declared.guards.loc:
    text: 'Вызов метода <code>#ref()</code> вне объявленных ограничений #loc'
change.type.arguments:
    text: Изменить аргументы типа
change.type.arguments.to.0:
    text: Изменить аргументы типа на <{0}>
change.visibility.level:
    text: Сделать {0} {1}
comparision.between.object.and.primitive:
    text: Сравнение между Object и примитивным типом является некорректным и принимается только в Java 7
contract.return.validator.incompatible.return.parameter.type:
    text: возвращаемый тип «{0}» должен быть приводимым от типа параметра «{1}»
contract.return.validator.method.return.incompatible.with.method.containing.class:
    text: возвращаемый тип метода должен быть совместим с классом, содержащим метод
contract.return.validator.not.applicable.for.constructor:
    text: не применимо для конструктора
contract.return.validator.not.applicable.primitive:
    text: не применимо для примитивного возвращаемого типа «{0}»
contract.return.validator.not.applicable.static:
    text: не применимо для статического метода
contract.return.validator.return.type.must.be.boolean:
    text: возвращаемый тип метода должен быть «boolean»
contract.return.validator.too.few.parameters:
    text: не применимо для метода, у которого {0, choice, 0#нет параметров|1#один параметр|2#{0} параметров}
contract.return.value.validation.prefix:
    text: 'Возвращаемое значение контракта «{0}»:'
convert.0.to.float:
    text: Преобразовать «{0}» в float
custom.exception.class.should.have.a.constructor:
    text: Пользовательский класс исключения должен иметь конструктор с одним строковым параметром сообщения
dataflow.constructor:
    text: Инициализатор класса
dataflow.message.array.index.out.of.bounds:
    text: Индекс массива выходит за пределы допустимого диапазона
dataflow.message.arraystore:
    text: Сохранение элемента типа <code>{0}</code> в массив элементов <code>{1}</code> приведет к <code>ArrayStoreException</code>
dataflow.message.assigning.null:
    text: <code>null</code> присваивается переменной с аннотацией @NotNull
dataflow.message.assigning.null.notannotated:
    text: Присваивание <code>null</code> значению полю без аннотации
dataflow.message.assigning.nullable:
    text: Выражение <code>#ref</code> может дать результат null, но присваивается переменной с аннотацией @NotNull
dataflow.message.assigning.nullable.notannotated:
    text: 'Выражение <code>#ref</code> #loc может быть null, но присваивается полю без аннотации'
dataflow.message.cce:
    text: 'Приведение <code>{0}</code> к <code>#ref</code> #loc может вызвать <code>ClassCastException</code>'
dataflow.message.cce.always:
    text: 'Приведение <code>{0}</code> к <code>#ref</code> #loc всегда вызовет <code>ClassCastException</code> для любого не-null значения'
dataflow.message.constant.condition:
    text: 'Условие <code>#ref</code> #loc всегда <code>{0, choice, 0#false|1#true}</code>'
dataflow.message.constant.condition.when.reached:
    text: 'Условие <code>#ref</code> #loc всегда <code>{0, choice, 0#false|1#true}</code> при достижении'
dataflow.message.constant.expression:
    text: 'Результат <code>#ref</code> #loc всегда «{0}»'
dataflow.message.constant.method.reference:
    text: Результат ссылки на метод всегда «{0}»
dataflow.message.constant.no.ref:
    text: Условие всегда {0, choice, 0#false|1#true}
dataflow.message.constant.value:
    text: 'Значение <code>#ref</code> #loc всегда «{0}»'
dataflow.message.contract.fail:
    text: Вызов «#ref» всегда завершается неудачей, согласно контракту метода
dataflow.message.contract.fail.index:
    text: Вызов «#ref» всегда завершается неудачей, так как индекс выходит за пределы допустимого диапазона
dataflow.message.immutable.modified:
    text: Неизменяемый объект изменяется
dataflow.message.immutable.passed:
    text: Неизменяемый объект передаётся туда, где ожидается изменяемый
dataflow.message.npe.array.access:
    text: 'Доступ к массиву <code>#ref</code> #loc может вызвать <code>NullPointerException</code>'
dataflow.message.npe.array.access.sure:
    text: 'Доступ к массиву <code>#ref</code> #loc вызовет <code>NullPointerException</code>'
dataflow.message.npe.field.access:
    text: 'Разыменование ссылки на поле <code>#ref</code> #loc может вызвать <code>NullPointerException</code>'
dataflow.message.npe.field.access.sure:
    text: 'Разыменование ссылки на поле <code>#ref</code> #loc вызовет <code>NullPointerException</code>'
dataflow.message.npe.inner.class.construction:
    text: Создание внутреннего класса может вызвать <code>NullPointerException</code>
dataflow.message.npe.inner.class.construction.sure:
    text: Создание внутреннего класса вызовет <code>NullPointerException</code>
dataflow.message.npe.method.invocation:
    text: 'Вызов метода <code>#ref</code> #loc может вызвать <code>NullPointerException</code>'
dataflow.message.npe.method.invocation.sure:
    text: 'Вызов метода <code>#ref</code> #loc вызовет <code>NullPointerException</code>'
dataflow.message.npe.methodref.invocation:
    text: 'Вызов ссылки на метод <code>#ref</code> #loc может вызвать <code>NullPointerException</code>'
dataflow.message.only.switch.label:
    text: 'Ветка switch <code>#ref</code> #loc является единственной достижимой во всем switch'
dataflow.message.passing.non.null.argument.to.optional:
    text: Передача не-null аргумента в <code>Optional</code>
dataflow.message.passing.null.argument:
    text: Передача <code>null</code> аргумента параметру, аннотированному как @NotNull
dataflow.message.passing.null.argument.nonannotated:
    text: Передача <code>null</code> аргумента параметру без аннотации
dataflow.message.passing.null.argument.to.optional:
    text: Передача <code>null</code>-аргумента в <code>Optional</code>
dataflow.message.passing.nullable.argument:
    text: 'Аргумент <code>#ref</code> #loc может быть null'
dataflow.message.passing.nullable.argument.methodref:
    text: Аргумент ссылки на метод может быть null
dataflow.message.passing.nullable.argument.methodref.nonannotated:
    text: Аргумент ссылки на метод может быть null, но передается в параметр без аннотации
dataflow.message.passing.nullable.argument.nonannotated:
    text: 'Аргумент <code>#ref</code> #loc может быть null, но передается в параметр без аннотации'
dataflow.message.pointless.assignment.expression:
    text: 'Условие <code>#ref</code> #loc в левой части выражения присваивания всегда равно <code>{0}</code>. Можно упростить'
dataflow.message.pointless.same.argument.and.result:
    text: Результат «#ref» совпадает с {0,choice,1#первым|2#вторым} аргументом, что делает вызов бессмысленным
dataflow.message.pointless.same.arguments:
    text: Аргументы «#ref» одинаковы. Вызов этого метода с одинаковыми аргументами бессмыслен
dataflow.message.redundant.assignment:
    text: Переменной уже присвоено это значение
dataflow.message.redundant.instanceof:
    text: 'Условие <code>#ref</code> #loc является избыточным и может быть заменено проверкой на null'
dataflow.message.redundant.update:
    text: Обновление переменной ничего не делает
dataflow.message.return.notnull.from.nullable:
    text: '@{0} метод «{1}» всегда возвращает не-null значение'
dataflow.message.return.null.from.notnull:
    text: <code>null</code> возвращается методом, объявленным как @{0}
dataflow.message.return.null.from.notnullable:
    text: <code>null</code> возвращается методом, который не объявлен как @{0}
dataflow.message.return.nullable.from.notnull:
    text: Выражение <code>#ref</code> может дать null, но возвращается методом, объявленным как @{0}
dataflow.message.return.nullable.from.notnull.function:
    text: Функция может вернуть null, но здесь это недопустимо
dataflow.message.return.nullable.from.notnullable:
    text: Выражение <code>#ref</code> может дать null, но возвращается методом, который не объявлен как @{0}
dataflow.message.storing.array.null:
    text: <code>null</code> сохраняется в массив элементов @NotNull
dataflow.message.storing.array.nullable:
    text: Выражение <code>#ref</code> может дать null, но сохраняется в массив элементов @NotNull
dataflow.message.unboxing:
    text: 'Распаковка <code>#ref</code> #loc может привести к <code>NullPointerException</code>'
dataflow.message.unboxing.method.reference:
    text: 'Использование <code>#ref</code> #loc потребует распаковки, которая может привести к <code>NullPointerException</code>'
dataflow.message.unboxing.nullable.argument.methodref:
    text: Передача аргумента в ссылку на метод требует распаковки, которая может привести к <code>NullPointerException</code>
dataflow.message.unreachable.switch.label:
    text: 'Ветка switch <code>#ref</code> #loc недостижима'
dataflow.method.fails.with.null.argument:
    text: Метод выбросит исключение, когда параметр равен null
dataflow.method.with.name.template:
    text: Метод <code>#ref</code>
dataflow.not.precise:
    text: '{0} является сложным: результаты анализа потока данных могут быть неточными'
dataflow.too.complex:
    text: '{0} слишком сложен для анализа алгоритмом потока данных'
delete.repeated.0:
    text: Удалить повторяющийся «{0}»
delete.repeated.interface:
    text: Удалить повторяющийся интерфейс
delimiters.argument.contains.duplicated.characters:
    text: Аргумент разделителей содержит дублирующиеся символы
deprecated.class.usage.group.xml:
    text: XML
deprecated.member.0.is.still.used:
    text: Устаревший член «{0}» все еще используется
detach.library.quickfix.name:
    text: Отключить библиотеку
detach.library.roots.quickfix.name:
    text: Отключить неиспользуемые корневые каталоги библиотек
dfa.find.cause.an.execution.might.exist.where:
    text: 'может существовать вариант исполнения, где:'
dfa.find.cause.array.length.is.always.non.negative:
    text: длина массива всегда неотрицательна
dfa.find.cause.call.always.fails:
    text: вызов всегда завершается неудачно
dfa.find.cause.cast.may.fail:
    text: приведение типа может завершиться неудачно
dfa.find.cause.collection.size.is.always.non.negative:
    text: размер коллекции всегда неотрицателен
dfa.find.cause.comparison.arguments.are.different.constants:
    text: аргументы сравнения являются разными константами
dfa.find.cause.comparison.arguments.are.the.same:
    text: аргументы сравнения одинаковы
dfa.find.cause.compile.time.constant:
    text: это константа времени компиляции, которая вычисляется как «{0}»
dfa.find.cause.condition.is.known.from.place:
    text: известно, что «{0}» из ___PLACE___
dfa.find.cause.condition.joiner:
    text: ' и'
dfa.find.cause.condition.was.checked.before:
    text: условие «{0}» было проверено ранее
dfa.find.cause.condition.was.deduced:
    text: условие «{0}» было выведено
dfa.find.cause.contract.kind.explicit:
    text: контракт
dfa.find.cause.contract.kind.hard.coded:
    text: жёстко закодированный контракт
dfa.find.cause.contract.kind.inferred:
    text: выведенный контракт
dfa.find.cause.contract.returns.on.condition:
    text: согласно {0}, метод «{1}» возвращает «{2}» значение, когда {3}
dfa.find.cause.contract.throws.on.condition:
    text: согласно {0}, метод «{1}» выбрасывает исключение, когда {2}
dfa.find.cause.contract.trivial:
    text: согласно {0}, метод «{1}» всегда возвращает «{2}» значение
dfa.find.cause.equality.established.from.condition:
    text: '«{0}» было установлено из условия'
dfa.find.cause.field.assigned.nullability:
    text: известно, что поле «{0}» всегда инициализируется значением «{1}»
dfa.find.cause.field.initializer.nullability:
    text: поле «{0}» инициализируется значением «{1}»
dfa.find.cause.instanceof.implies.non.nullity:
    text: проверка «instanceof» подразумевает не-null значение
dfa.find.cause.left.operand.range.template:
    text: левый операнд — %s
dfa.find.cause.may.be.null:
    text: может быть null
dfa.find.cause.nonnull.expression.kind.concatenation:
    text: конкатенация
dfa.find.cause.nonnull.expression.kind.literal:
    text: литерал
dfa.find.cause.nonnull.expression.kind.newly.created.object:
    text: вновь созданный объект
dfa.find.cause.nonnull.expression.kind.primitive.type:
    text: значение примитивного типа «{0}»
dfa.find.cause.nonnull.expression.kind.this.object:
    text: объект «this»
dfa.find.cause.nullability.explicitly.annotated:
    text: '{0} «{1}» снабжён аннотацией «{2}»'
dfa.find.cause.nullability.externally.annotated:
    text: '{0} «{1}» снабжён внешней аннотацией «{2}»'
dfa.find.cause.nullability.inferred:
    text: '{0} «{1}» был выведен как «{2}»'
dfa.find.cause.nullability.inherited.from.class:
    text: '{0} «{1}» наследует аннотацию от класса {2}, таким образом «{3}»'
dfa.find.cause.nullability.inherited.from.container:
    text: '{0} «{1}» наследует аннотацию контейнера, таким образом «{2}»'
dfa.find.cause.nullability.inherited.from.named.element:
    text: '{0} «{1}» наследует от {2}, таким образом «{3}»'
dfa.find.cause.nullability.inherited.from.package:
    text: '{0} «{1}» наследует аннотацию от пакета {2}, таким образом «{3}»'
dfa.find.cause.numeric.cast.operand.template:
    text: операнд приведения типа — %s
dfa.find.cause.numeric.range.generic.template:
    text: значение — %s
dfa.find.cause.object.kind.expression:
    text: выражение
dfa.find.cause.object.kind.generic:
    text: объект
dfa.find.cause.object.kind.method.return:
    text: результат метода
dfa.find.cause.obviously.non.null.expression:
    text: выражение не может быть null, так как оно {0}
dfa.find.cause.one.of.the.following.happens:
    text: 'происходит одно из следующих событий:'
dfa.find.cause.operand.of.boolean.expression.is.the.same:
    text: 'операнд #{0} {1, choice, 0#и|1#или}-цепочки равен {2}'
dfa.find.cause.place.here:
    text: здесь
dfa.find.cause.place.line.number:
    text: 'строка #{0}'
dfa.find.cause.range.is.known.from.place:
    text: диапазон известен из ___PLACE___
dfa.find.cause.range.is.specified.by.annotation:
    text: диапазон «{0}» указан в аннотации как {1}
dfa.find.cause.result.of.numeric.operation.template:
    text: результат «{0}» равен %s
dfa.find.cause.result.of.primitive.cast.template:
    text: результат приведения типа «({0})» равен %s
dfa.find.cause.right.operand.range.template:
    text: правый операнд — %s
dfa.find.cause.string.length.is.always.non.negative:
    text: длина строки всегда неотрицательна
dfa.find.cause.type.is.known.from.place:
    text: тип «{0}» известен из ___PLACE___
dfa.find.cause.type.known:
    text: тип «{0}» — {1}
dfa.find.cause.unable:
    text: Не удалось найти причину
dfa.find.cause.value.is.always.the.same:
    text: значение всегда {0}
dfa.find.cause.value.is.known.from.place:
    text: '«{0}» известно как «{1}» из ___PLACE___'
dfa.find.cause.value.x.is.always.the.same:
    text: значение «{0}» всегда «{1}»
dfa.find.cause.values.cannot.be.equal.because:
    text: значения не могут быть равны, потому что {0}
dfa.find.cause.variable.is.initialized:
    text: '{0} «{1}» инициализируется значением {2}'
dfa.find.cause.was.assigned:
    text: '«{0}» было присвоено'
dfa.find.cause.was.assigned.to:
    text: '«{0}» было присвоено «{1}»'
dfa.find.cause.was.dereferenced:
    text: '«{0}» было разыменовано'
dfa.find.cause.was.passed.as.non.null.parameter:
    text: '«{0}» было передано в качестве аргумента методу, принимающему не-null параметр'
dftype.presentation.empty.optional:
    text: пустой Optional
dftype.presentation.present.optional:
    text: непустой Optional
don.t.report.unused.jars.inside.used.library:
    text: Не сообщать о неиспользуемых JAR-файлах внутри используемой библиотеки
duplication.policy.ask:
    text: Спросить
duplication.policy.generate.duplicate:
    text: Сгенерировать дублирующий метод
duplication.policy.replace:
    text: Заменить существующий
element.kind.keys:
    text: ключи
element.kind.objects:
    text: объекты
element.kind.values:
    text: значения
error.class.not.found:
    text: Класс {0} не найден
error.message.invalid.java.type:
    text: Недопустимый тип Java
exception.removal.will.break.source.code.proceed.anyway:
    text: Удаление исключения нарушит исходный код. Продолжить в любом случае?
explicit.type.argument.ref.loc.can.be.replaced.with:
    text: 'Явный аргумент типа #ref #loc можно заменить на <>'
exports.to.itself.delete.module.ref.fix:
    text: Удалить ссылку на модуль «{0}»
exports.to.itself.delete.statement.fix:
    text: Удалить директиву
feature.annotations:
    text: Аннотации
feature.binary.literals:
    text: Двоичные литералы
feature.diamond.types:
    text: Типы-ромбы
feature.enhanced.switch:
    text: Улучшенные блоки «switch»
feature.extension.methods:
    text: Методы расширения
feature.for.each:
    text: Циклы for-each
feature.generics:
    text: Обобщения (Generics)
feature.hex.fp.literals:
    text: Шестнадцатеричные литералы с плавающей запятой
feature.intersections.in.casts:
    text: Типы пересечений в приведениях
feature.lambda.expressions:
    text: Лямбда-выражения
feature.local.enums:
    text: Локальные перечисления (enum)
feature.local.interfaces:
    text: Локальные интерфейсы
feature.lvti:
    text: Вывод типа локальной переменной
feature.method.references:
    text: Ссылки на методы
feature.modules:
    text: Модули
feature.multi.catch:
    text: Множественные catch-блоки
feature.patterns.instanceof:
    text: Шаблоны в «instanceof»
feature.records:
    text: Записи
feature.sealed.classes:
    text: Запечатанные (sealed) классы
feature.static.imports:
    text: Статические импорты
feature.static.interface.calls:
    text: Статические вызовы методов интерфейса
feature.switch.expressions:
    text: 'switch-выражения'
feature.text.block.escape.sequences:
    text: Экранирующие последовательности «\s» и «\»
feature.text.blocks:
    text: Текстовые блоки
feature.try.with.resources:
    text: «try» с ресурсами
feature.try.with.resources.refs:
    text: Ссылки на ресурсы
feature.type.annotations:
    text: Аннотации типов
feature.type.receivers:
    text: Параметры-получатели
feature.underscores.in.literals:
    text: Подчеркивания в литералах
feature.var.lambda.parameter:
    text: '«var» в параметрах лямбда-выражений'
feature.varargs:
    text: Методы с переменным числом аргументов (varargs)
find.searching.for.references.to.class.progress:
    text: Поиск ссылок на класс {0}…
find.usages.panel.title.derived.classes:
    text: Производные классы
find.usages.panel.title.derived.interfaces:
    text: Производные интерфейсы
find.usages.panel.title.implementing.classes:
    text: Реализующие классы
find.usages.panel.title.implementing.methods:
    text: Реализующие методы
find.usages.panel.title.overloaded.methods.usages:
    text: Использование перегруженных методов
find.usages.panel.title.overriding.methods:
    text: Переопределяющие методы
generate.members.position.after.equals.and.hashcode:
    text: После equals() и hashCode()
generate.members.position.at.caret:
    text: В месте нахождения курсора
generate.members.position.at.the.end.of.class:
    text: В конце класса
html.classes.exposed.with.code.module.info.code.html:
    text: <html>Классы, раскрываемые с помощью <code>module-info</code></html>
html.ignore.overrides.of.deprecated.abstract.methods:
    text: <html>Игнорировать переопределения устаревших абстрактных методов из неустаревших суперклассов</html>
ignore.casts.in.suspicious.collections.method.calls:
    text: Игнорировать приведения типов в подозрительных вызовах методов коллекций
ignore.exceptions.thrown.by.entry.points.methods:
    text: Игнорировать исключения, выбрасываемые методами точек входа
ignore.in.the.same.outermost.class:
    text: Игнорировать в том же самом внешнем классе
ignore.inside.deprecated.members:
    text: Игнорировать внутри устаревших членов
ignore.inside.non.static.imports:
    text: Игнорировать внутри нестатических импортов
ignore.members.of.deprecated.classes:
    text: Игнорировать члены устаревших классов
ignore.operation.which.results.in.negative.value:
    text: Игнорировать операцию «<<», которая приводит к отрицательному значению
inspection.annotate.method.quickfix.family.name:
    text: Добавить аннотацию к методу
inspection.annotate.method.quickfix.name:
    text: Добавить к методу аннотацию «@{0}»
inspection.annotate.overridden.method.and.self.quickfix.family.name:
    text: Добавить аннотацию к этому и переопределенным методам
inspection.annotate.overridden.method.and.self.quickfix.name:
    text: Добавить аннотацию «@{0}» к этому и переопределенным методам
inspection.annotate.overridden.method.nullable.quickfix.name:
    text: Добавить аннотацию «@{0}» к переопределенным методам
inspection.annotate.overridden.method.quickfix.family.name:
    text: Добавить аннотацию к переопределенным методам
inspection.annotate.overridden.method.quickfix.name:
    text: Добавить аннотацию «@{0}» к переопределенным методам
inspection.anonymous.has.lambda.alternative.display.name:
    text: Анонимный тип имеет более короткую лямбда-альтернативу
inspection.block.marker.comments.display.name:
    text: Комментарий-маркер блока
inspection.c.style.array.declarations.option:
    text: Игнорировать объявления в стиле C в переменных
inspection.can.be.final.accept.quickfix:
    text: Сделать final
inspection.can.be.final.display.name:
    text: Объявление может иметь модификатор final
inspection.can.be.final.option:
    text: Сообщать о классах
inspection.can.be.final.option1:
    text: Сообщать о методах
inspection.can.be.final.option2:
    text: Сообщать о полях
inspection.can.be.local.parameter.problem.descriptor:
    text: Параметр <code>#ref</code> может иметь модификатор <code>final</code>
inspection.can.be.local.variable.problem.descriptor:
    text: Переменная <code>#ref</code> может иметь модификатор <code>final</code>
inspection.can.be.replaced.with.message:
    text: Может быть заменено на «{0}»
inspection.class.getclass.display.name:
    text: Вызов «Class.getClass()»
inspection.class.getclass.fix.remove.name:
    text: Удалить вызов «getClass()»
inspection.class.getclass.fix.replace.name:
    text: Заменить на «Class.class»
inspection.class.getclass.message:
    text: '«getClass()» вызывается для экземпляра Class'
inspection.class.has.no.to.string.method.description:
    text: Класс «{0}» не переопределяет метод «toString()»
inspection.class.has.no.to.string.method.display.name:
    text: Класс не переопределяет метод «toString()»
inspection.class.has.no.to.string.method.exclude.classes.reg.exp.option:
    text: 'Исключить классы (рег. выр.):'
inspection.class.has.no.to.string.method.ignore.abstract.classes.option:
    text: Игнорировать абстрактные классы
inspection.class.has.no.to.string.method.ignore.deprecated.classes.option:
    text: Игнорировать устаревшие классы
inspection.class.has.no.to.string.method.ignore.enum.classes.option:
    text: Игнорировать перечисления
inspection.class.has.no.to.string.method.ignore.exception.classes.option:
    text: Игнорировать классы исключений
inspection.class.has.no.to.string.method.ignore.inner.classes.option:
    text: Игнорировать вложенные классы
inspection.class.has.no.to.string.method.ignore.test.classes.option:
    text: Игнорировать тестовые классы
inspection.common.if.parts.disable.highlight.tail.call:
    text: Не выделять общие части, если последняя инструкция — вызов
inspection.common.if.parts.family:
    text: Извлечь общие части «if»
inspection.common.if.parts.family.else.if:
    text: Объединить «else if»
inspection.common.if.parts.family.else.if.description:
    text: '«else if» можно объединить'
inspection.common.if.parts.settings.highlight.when.tail.call:
    text: Выделять, когда последняя общая инструкция является вызовом
inspection.compiler.javac.quirks.anno.array.comma.fix:
    text: Удалить завершающую запятую
inspection.compiler.javac.quirks.anno.array.comma.problem:
    text: Завершающая запятая в инициализаторе массива аннотации может вызвать ошибку компиляции в некоторых версиях Javac (например, JDK 5 и JDK 6).
inspection.compiler.javac.quirks.name:
    text: Особенности Javac
inspection.compiler.javac.quirks.qualifier.type.args.fix:
    text: Удалить параметр обобщения
inspection.compiler.javac.quirks.qualifier.type.args.problem:
    text: Обобщения в ссылке на квалификатор могут вызвать ошибку компиляции в некоторых версиях Javac (например, JDK 5 и JDK 6).
inspection.constant.on.wrong.side.of.a.comparison.side.option:
    text: 'Константа должна находиться на этой стороне сравнения:'
inspection.contract.checker.boolean.condition.for.nonboolean.parameter:
    text: Параметр «{0}» имеет тип «{1}» (ожидался boolean)
inspection.contract.checker.clause.syntax:
    text: Определение контракта должно быть в форме арг1, …, аргN -> возвращаемое_значение
inspection.contract.checker.contract.clause.never.satisfied:
    text: Определение контракта «{0}» никогда не удовлетворяется, так как его условия покрыты предыдущими контрактами
inspection.contract.checker.contract.violated:
    text: Определение контракта «{0}» нарушено
inspection.contract.checker.empty.constraint:
    text: Ограничение не должно быть пустым
inspection.contract.checker.inferred.notnull.parameter.notnull:
    text: Параметр «{0}» выведен как not-null, поэтому «!null» всегда удовлетворяется
inspection.contract.checker.inferred.notnull.parameter.null:
    text: Параметр «{0}» выведен как not-null, поэтому «null» неприменим
inspection.contract.checker.method.always.fails.nontrivial:
    text: Возвращаемое значение определения «{0}» может быть заменено на «fail», так как метод в этом случае всегда завершается неудачно
inspection.contract.checker.method.always.fails.trivial:
    text: Возвращаемое значение определения «{0}» может быть заменено на «fail», так как метод всегда завершается неудачно
inspection.contract.checker.no.exception.thrown:
    text: 'Определение контракта «{0}» нарушено: исключение не выбрасывается'
inspection.contract.checker.notnull.parameter.notnull:
    text: Параметр «{0}» снабжён аннотацией not-null, поэтому «!null» всегда удовлетворяется
inspection.contract.checker.notnull.parameter.null:
    text: Параметр «{0}» снабжён аннотацией как not-null, поэтому «null» неприменим
inspection.contract.checker.parameter.count.mismatch:
    text: Метод принимает {0} параметров, в то время как определение контракта «{1}» ожидает {2}
inspection.contract.checker.primitive.parameter.nullability:
    text: Параметр «{0}» имеет примитивный тип «{1}», поэтому «{2}» неприменим
inspection.contract.checker.pure.method.mutation.contract:
    text: Чистый метод не может иметь контракт мутации
inspection.contract.checker.unknown.constraint:
    text: 'Ограничение должно быть одним из: {0}. Найдено: {1}'
inspection.contract.checker.unknown.return.value:
    text: 'Возвращаемое значение должно быть одним из: {0}. Найдено: {1}'
inspection.contract.checker.unreachable.contract.clause:
    text: 'Определение контракта «{0}» недостижимо: предыдущие контракты покрывают все возможные случаи'
inspection.contract.display.name:
    text: Проблемы контракта
inspection.convert.2.diamond.display.name:
    text: Явный тип можно заменить на <>
inspection.convert.2.lambda.display.name:
    text: Анонимный тип можно заменить лямбда-выражением
inspection.data.flow.redundant.instanceof.quickfix:
    text: Заменить на проверку на null
inspection.data.flow.simplify.boolean.expression.quickfix:
    text: Упростить логическое выражение
inspection.data.flow.simplify.to.assignment.quickfix.name:
    text: Упростить до обычного присваивания
inspection.data.flow.turn.off.constant.references.quickfix:
    text: Не сообщать о значениях, которые гарантированно являются константами
inspection.data.flow.turn.off.nullable.returning.notnull.quickfix:
    text: Не сообщать о возвращающих null методах, которые всегда возвращают не-null значение
inspection.data.flow.turn.off.true.asserts.quickfix:
    text: Не сообщать о всегда истинных утверждениях
inspection.deprecated.class.usage.inspection.display.name:
    text: Использование устаревшего API в XML
inspection.deprecated.is.still.used.display.name:
    text: Устаревший член все еще используется
inspection.duplicate.throws.display.name:
    text: Дублирующиеся «throws»
inspection.duplicate.throws.ignore.subclassing.option:
    text: Игнорировать исключения, наследующиеся от других
inspection.duplicate.throws.more.general.problem:
    text: В списке «throws» уже есть более общее исключение, «{0}».
inspection.duplicate.throws.problem:
    text: Дублирующиеся «throws»
inspection.equals.hashcode.only.one.defined.problem.descriptor:
    text: В классе определён {0}, но не определён {1}
inspection.export.results.can.be.final.description:
    text: Объявление может иметь модификатор «final»
inspection.field.access.not.guarded.display.name:
    text: Незащищённый доступ к полю или вызов метода
inspection.field.not.used.in.to.string.description:
    text: Метод «{0}» не используется в методе «toString()»
inspection.field.not.used.in.to.string.description2:
    text: Поле «{0}» не используется в методе «toString()»
inspection.field.not.used.in.to.string.display.name:
    text: Поле не используется в методе «toString()»
inspection.i18n.quickfix.annotate:
    text: Добавить аннотацию…
inspection.i18n.quickfix.annotate.as:
    text: Добавить аннотацию @{0}
inspection.i18n.quickfix.annotate.element:
    text: Добавить {0} аннотацию «{1}»…
inspection.i18n.quickfix.annotate.element.as:
    text: Добавить {0} «{1}» аннотацию @{2}
inspection.implicit.subclass.display.forClass:
    text: Класс «{0}» может иметь неявных потомков и не должен быть final
inspection.implicit.subclass.display.name:
    text: Объявление «final» не может быть переопределено во время выполнения
inspection.implicit.subclass.extendable:
    text: Сделать «{0}» переопределяемым
inspection.implicit.subclass.make.class.extendable:
    text: Сделать класс «{0}» {1,choice,0#|1#и метод {2} |1<и {1} требуемых методов }расширяемым
inspection.inconsistent.language.level.display.name:
    text: Несогласованные настройки уровня языка
inspection.infinite.loop.option:
    text: Игнорировать, если помещен в «Thread.run»
inspection.instance.guarded.by.static.display.name:
    text: Член экземпляра, защищённый статическим полем
inspection.invalid.comparator.method.reference.display.name:
    text: Недопустимая ссылка на метод, используемый в Comparator
inspection.java.8.list.sort.display.name:
    text: «Collections.sort()» можно заменить на «List.sort()»
inspection.java.9.redundant.requires.statement.display.name:
    text: Избыточное утверждение «requires» в module-info
inspection.java.module.naming:
    text: Соглашения об именовании модулей Java
inspection.java.module.naming.terminal.digits:
    text: Компонент названия модуля «{0}» должен избегать конечных цифр
inspection.local.can.be.final.display.name:
    text: Локальная переменная или параметр могут быть «final»
inspection.local.can.be.final.option:
    text: Сообщать о локальных переменных
inspection.local.can.be.final.option1:
    text: Сообщать о параметрах метода
inspection.local.can.be.final.option2:
    text: Сообщать о параметрах «catch»
inspection.local.can.be.final.option3:
    text: Сообщать о параметрах «for-each»
inspection.local.can.be.final.option4:
    text: Сообщать о переменных, которые являются неявно «final»
inspection.message.code.generation.different.nullability.annotation.will.be.used:
    text: Сгенерированный код будет использовать «{1}» вместо «{0}».
inspection.message.javac.quick.intersection.type.problem:
    text: 'Хотя присваивание формально корректно, оно может привести к ClassCastException во время выполнения. Ожидалось: «{0}», фактически: «{1}»'
inspection.message.non.annotated.method.implements.non.null.method:
    text: Неаннотированный метод «{0}» из «{1}» реализует не-null метод из «{2}»
inspection.message.non.annotated.parameter.should.not.override.non.null.parameter:
    text: Неаннотированный параметр «{0}» в методе «{1}» из «{2}» не должен переопределять non-null параметр из «{3}»
inspection.message.non.null.parameter.should.not.override.non.annotated.parameter:
    text: Не-null параметр «{0}» в методе «{1}» из «{2}» не должен переопределять неаннотированный параметр из «{3}»
inspection.message.non.null.parameter.should.not.override.nullable.parameter:
    text: Не-null параметр «{0}» в методе «{1}» из «{2}» не должен переопределять nullable параметр из «{3}»
inspection.message.nullable.method.implements.non.null.method:
    text: Nullable метод «{0}» из «{1}» реализует не-null метод из «{2}»
inspection.module.exports.package.to.itself:
    text: Модуль экспортирует/открывает пакет самому себе
inspection.non.final.field.in.immutable.display.name:
    text: Не-final поле в @Immutable классе
inspection.non.final.guard.display.name:
    text: Не-final @GuardedBy поле
inspection.nullable.problems.NotNull.parameter.overrides.Nullable:
    text: Параметр с аннотацией @{0}, не должен переопределять параметр @{1}
inspection.nullable.problems.NotNull.parameter.overrides.not.annotated:
    text: Параметр с аннотацией @{0}, не должен переопределять неаннотированный параметр
inspection.nullable.problems.NotNull.parameter.receives.null.literal:
    text: Параметр с аннотацией @{0}, не должен принимать «null» в качестве аргумента
inspection.nullable.problems.Nullable.NotNull.conflict:
    text: Нельзя добавить одновременно аннотации @{0} и @{1}
inspection.nullable.problems.Nullable.method.overrides.NotNull:
    text: Метод с аннотацией @{0}, не должен переопределять метод @{1}
inspection.nullable.problems.annotated.field.constructor.parameter.not.annotated:
    text: Параметр конструктора для поля @{0} может сам быть снабжён аннотацией @{0}
inspection.nullable.problems.annotated.field.getter.conflict:
    text: Геттер для поля @{0} снабжён аннотацией @{1}
inspection.nullable.problems.annotated.field.getter.not.annotated:
    text: Геттер для поля @{0} может быть сам снабжён аннотацией @{0}
inspection.nullable.problems.annotated.field.setter.parameter.conflict:
    text: Параметр сеттера для поля @{0} снабжён аннотацией @{1}
inspection.nullable.problems.annotated.field.setter.parameter.not.annotated:
    text: Параметр сеттера для поля @{0} может быть сам снабжён аннотацией @{0}
inspection.nullable.problems.method.overrides.NotNull:
    text: Метод без аннотаций переопределяет метод, аннотированный @{0}
inspection.nullable.problems.parameter.overrides.NotNull:
    text: Параметр без аннотаций переопределяет параметр @{0}
inspection.nullable.problems.primitive.type.annotation:
    text: Члены примитивных типов не могут быть снабжены аннотациями
inspection.numeric.overflow.display.name:
    text: Переполнение числа
inspection.objects.equals.can.be.simplified.display.name:
    text: «Objects.equals()» можно заменить на «equals()»
inspection.redundant.cast.display.name:
    text: Избыточное приведение типов
inspection.redundant.cast.problem.descriptor:
    text: Приведение {0} к {1} избыточно
inspection.redundant.cast.remove.quickfix:
    text: Удалить избыточные приведения типов
inspection.redundant.field.initialization.option:
    text: Предупреждать только при инициализации null
inspection.redundant.requires.statement.description:
    text: Избыточная директива «requires {0}»
inspection.redundant.requires.statement.fix.family:
    text: Удалить избыточную директиву «requires»
inspection.redundant.requires.statement.fix.name:
    text: Удалить директиву «requires {0}»
inspection.redundant.throws.display.name:
    text: Избыточное объявление «throws»
inspection.redundant.throws.problem.descriptor:
    text: Объявленное исключение {0} никогда не выбрасывается в реализациях методов
inspection.redundant.throws.problem.descriptor1:
    text: Объявленное исключение {0} никогда не выбрасывается ни в этом методе, ни в его производных
inspection.redundant.throws.problem.descriptor2:
    text: Объявленное исключение {0} никогда не выбрасывается
inspection.redundant.throws.remove.quickfix:
    text: Удалить ненужные объявления «throws»
inspection.redundant.type.display.name:
    text: Избыточные аргументы типа
inspection.redundant.type.no.generics.method.reference.problem.descriptor:
    text: Аргументы типа избыточны для не обобщённой ссылки на метод
inspection.redundant.type.no.generics.problem.descriptor:
    text: Аргументы типа избыточны для вызова не обобщённого метода
inspection.redundant.type.problem.descriptor:
    text: Явные аргументы типа могут быть выведены
inspection.redundant.type.remove.quickfix:
    text: Удалить аргументы типа
inspection.reference.anonymous.name:
    text: анонимный ({0})
inspection.reference.default.package:
    text: <по умолчанию>
inspection.reference.implicit.constructor.name:
    text: неявный конструктор {0}
inspection.reference.jsp.holder.method.anonymous.name:
    text: <% содержимое страницы %>
inspection.requires.auto.module:
    text: Зависимости от автоматических модулей
inspection.requires.auto.module.message:
    text: Директива «requires» для автоматического модуля
inspection.requires.auto.module.option:
    text: Выделять только транзитивные зависимости
inspection.requires.auto.module.transitive:
    text: Директива «requires transitive» для автоматического модуля
inspection.safe.varargs.detector.display.name:
    text: Возможное загрязнение кучи от параметризованного vararg типа
inspection.same.return.value.display.name:
    text: Метод возвращает одно и то же значение
inspection.same.return.value.problem.descriptor:
    text: Метод всегда возвращает {0}
inspection.same.return.value.problem.descriptor1:
    text: Метод и все его производные всегда возвращают {0}
inspection.same.return.value.problem.descriptor2:
    text: Все реализации этого метода всегда возвращают {0}
inspection.static.guarded.by.instance.display.name:
    text: Статический член, защищённый полем экземпляра или this
inspection.string.tokenizer.delimiter.display.name:
    text: Дублирующиеся разделители в «java.util.StringTokenizer»
inspection.surround.requirenonnull.quickfix:
    text: Заменить на «Objects.requireNonNull({0})»
inspection.suspicious.array.method.call.display.name:
    text: Подозрительные вызовы методов «Arrays»
inspection.suspicious.array.method.call.problem.arrays:
    text: 'Типы массивов несовместимы: массивы всегда разные'
inspection.suspicious.array.method.call.problem.element:
    text: Тип элемента несовместим с типом массива
inspection.suspicious.collections.method.calls.display.name:
    text: Подозрительные вызовы методов коллекций
inspection.suspicious.collections.method.calls.problem.descriptor:
    text: '«{0}» может не содержать {2} типа «{1}»'
inspection.suspicious.collections.method.calls.problem.descriptor1:
    text: Подозрительный вызов «{0}»
inspection.suspicious.getter.setter.field.option:
    text: Предупреждать только при наличии поля, соответствующего названию геттера/сеттера
inspection.suspicious.integer.div.assignment.option:
    text: Сообщать о подозрительных, но потенциально точных делениях
inspection.test.only.problems.display.name:
    text: Класс или вызов метода только для тестов в боевом коде
inspection.test.only.problems.test.only.class.reference:
    text: Класс только для тестов ссылается в боевом коде
inspection.test.only.problems.test.only.field.reference:
    text: Поле только для тестов ссылается в боевом коде
inspection.test.only.problems.test.only.method.call:
    text: Метод только для тестов вызывается в боевом коде
inspection.unary.plus.unary.binary.option:
    text: Сообщать только в запутанном контексте бинарного или унарного выражения
inspection.unknown.guard.display.name:
    text: Неизвестное @GuardedBy поле
inspection.unnecessary.super.qualifier.option:
    text: Игнорировать уточняющий префикс «super»
inspection.use.compare.method.display.name:
    text: Метод «compare()» может использоваться для сравнения чисел
inspection.use.compare.method.fix.family.name:
    text: Заменить на единый метод сравнения
inspection.visibility.accept.quickfix:
    text: Принять предложенный уровень доступа
inspection.visibility.compose.suggestion:
    text: Может быть {0}
inspection.visibility.option.constants:
    text: Предлагать более слабый уровень видимости для констант
inspection.visibility.option.package.private.members:
    text: Предлагать уровень видимости package-private для членов класса
inspection.visibility.package.private.top.level.classes:
    text: Предлагать уровень видимости package-private для классов верхнего уровня
inspection.visibility.private.inner.members:
    text: <html>Предлагать private для членов вложенного класса, если на них ссылаются только из внешнего класса</html>
inspection.weaker.access.display.name:
    text: Доступ объявления может быть более слабым
instance.member.guarded.by.static.0.loc:
    text: 'Член экземпляра, защищенный статическим полем «{0}» #loc'
instance.member.guarded.by.static.ref.loc:
    text: 'Член экземпляра, защищенный статическим #ref #loc'
intention.add.annotation.family:
    text: Добавить аннотацию
intention.name.qualify.expression:
    text: Квалифицировать выражение {0} с помощью «{1}»
intention.text.remove.annotation:
    text: Удалить
junit.rule.classrule.option:
    text: Сообщать о проблемах @ClassRule
junit.rule.rule.option:
    text: Сообщать о проблемах @Rule
long.range.set.presentation.any:
    text: любое значение
long.range.set.presentation.divisible.by:
    text: делится на {0}
long.range.set.presentation.empty:
    text: неизвестно
long.range.set.presentation.even:
    text: чётное
long.range.set.presentation.odd:
    text: нечётное
long.range.set.presentation.range:
    text: в {0}
long.range.set.presentation.range.with.mod:
    text: '{0}; {1}'
long.range.set.presentation.two.values:
    text: '{0} или {1}'
make.0.default.annotation:
    text: Сделать «{0}» аннотацией по умолчанию
make.default.the.last.case.family.name:
    text: Сделать «default» последним в списке
make.final.and.annotate.as.safevarargs:
    text: Сделать «final» и добавить аннотацию @SafeVarargs
message.class.inaccessible:
    text: Класс «{0}» здесь недоступен
message.class.inaccessible.from.module:
    text: Класс «{0}» недоступен из модуля «{1}»
method.reference.mapped.to.comparator:
    text: Ссылка на метод, сопоставленная интерфейсу Comparator, не выполняет контракт Comparator
module.0.with.language.level.1.depends.on.module.2.with.language.level.3:
    text: Модуль {0} с уровнем языка {1} зависит от модуля {2} с уровнем языка {3}
move.0.to.the.beginning:
    text: Переместить «{0}» в начало
move.to.front:
    text: Переместить вперёд
mutability.modifiable:
    text: изменяемый
mutability.unknown:
    text: неизвестно
mutability.unmodifiable:
    text: неизменяемый
mutability.unmodifiable.view:
    text: неизменяемое представление
mutation.signature.problem.invalid.token:
    text: 'Недопустимый токен: {0}; поддерживаются «this», «param1», «param2» и т. д.'
mutation.signature.problem.parameter.has.immutable.type:
    text: 'Параметр #{0} имеет неизменяемый тип «{1}»'
mutation.signature.problem.reference.to.parameter.invalid:
    text: 'Ссылка на параметр #{0} недопустима'
mutation.signature.problem.static.method.cannot.mutate.this:
    text: Статический метод не может изменять «this»
navigate.to.overridden.methods.title:
    text: Переопределяющие методы {0}
non.final.field.code.ref.code.in.immutable.class.loc:
    text: 'Не-final поле <code>#ref</code> в @Immutable классе #loc'
non.final.guarded.by.field.0.loc:
    text: 'Не-final @GuardedBy поле «{0}» #loc'
non.final.guarded.by.field.ref.loc:
    text: 'Не-final @GuardedBy поле #ref #loc'
non.null.type.argument.is.expected:
    text: Ожидается не-null аргумент типа
not.annotated.method.is.used.as.an.override.for.a.method.annotated.with.0:
    text: Метод без аннотаций используется как переопределение для метода с аннотацией {0}
nullability.non.null:
    text: не-null
nullability.null:
    text: 'null'
nullability.nullable:
    text: nullable
nullable.stuff.error.overriding.notnull.with.nullable:
    text: Переопределение коллекции не-null элементов коллекцией с nullable-элементами
nullable.stuff.error.overriding.nullable.with.notnull:
    text: Переопределение коллекции nullable-элементов коллекцией с не-null элементами
nullable.stuff.problems.overridden.method.parameters.are.not.annotated:
    text: Параметры переопределённого метода без аннотаций
nullable.stuff.problems.overridden.methods.are.not.annotated:
    text: Переопределенные методы без аннотаций
parameter.can.be.null:
    text: Параметр может быть null
parameter.is.always.not.null:
    text: Параметр всегда не null
possible.heap.pollution.from.parameterized.vararg.type.loc:
    text: 'Возможное загрязнение кучи от параметризованного vararg типа #loc'
processing.method.usages:
    text: Обработка использования методов…
progress.title.searching.for.overridden.methods:
    text: Поиск переопределённых методов
provided.type:
    text: Предоставлено
qualify.0:
    text: Квалифицировать {0}
qualify.with.0.this:
    text: Квалифицировать с {0}.this
redundant.block.marker:
    text: Избыточный маркер блока
remove.annotation:
    text: Удалить аннотацию
remove.block.marker.comments:
    text: Удалить комментарии-маркеры блока
remove.dependency:
    text: Удалить зависимость
remove.left.side.of.assignment:
    text: Удалить левую часть присваивания
remove.switch.branch.0:
    text: Удалить ветку switch «{0}»
remove.switch.label:
    text: Удалить ветку switch
remove.switch.label.0:
    text: Удалить ветку switch «{0}»
replace.0.with:
    text: Заменить «{0}» на «=»
replace.get.class.with.class.literal:
    text: Заменить «getClass()» на .class-литерал
replace.operator.assignment.with.assignment:
    text: Заменить составное присваивание на присваивание
replace.stringtokenizer.delimiters.parameter.with.unique.symbols:
    text: Заменить параметр разделителей StringTokenizer на уникальные символы
replace.var.with.explicit.type:
    text: Заменить «var» на явный тип
replace.with.0:
    text: Заменить на {0}
replace.with.comparator:
    text: Заменить на компаратор
replace.with.constant.value:
    text: Заменить на константное значение
replace.with.expression.lambda:
    text: Заменить на лямбда-выражение
replace.with.lambda:
    text: Заменить на лямбда-выражение
report.suspicious.but.possibly.correct.method.calls:
    text: '&Сообщать о подозрительных, но потенциально корректных вызовах методов'
report.when.interface.is.not.annotated.with.functional.interface:
    text: Сообщать, когда интерфейс без аннотации @FunctionalInterface
required.type:
    text: Требуемый тип
scope.package:
    text: Пакет {0}
searching.for.overriding.methods:
    text: Поиск переопределяющих методов
service.provides:
    text: 'Предоставляет сервис <a href="#javaClass/{0}">{0}</a><br><div style="margin-top: 5px"><font size="2">Нажмите для перехода</font></div>'
service.uses:
    text: 'Использует сервис <a href="#javaClass/{0}">{0}</a><br><div style="margin-top: 5px"><font size="2">Нажмите для перехода</font></div>'
special.field.array.length:
    text: Длина массива
special.field.collection.size:
    text: Размер
special.field.optional.value:
    text: Значение Optional
special.field.string.length:
    text: Длина строки
special.field.unboxed.value:
    text: Распакованное значение
statement.lambda.can.be.replaced.with.expression.lambda:
    text: Лямбда-оператор может быть заменен на лямбда-выражение
static.inheritrance.fix.replace.progress:
    text: Замена использований {0}
static.member.guarded.by.instance.0.loc:
    text: 'Статический член, защищенный экземпляром «{0}» #loc'
static.member.guarded.by.instance.ref.loc:
    text: 'Статический член, защищенный экземпляром #ref #loc'
subclasses.search.progress.title:
    text: Поиск переопределённых методов
suggest.package.private.visibility.level.for.classes.in.exported.packages.java.9:
    text: Предлагать уровень видимости package-private для классов в экспортируемых пакетах (Java 9+)
suppress.all.for.class:
    text: Подавить все инспекции для класса
suppress.for.parameter:
    text: Подавить для параметра
suppress.for.statement.with.comment:
    text: Подавить для оператора с комментарием
suppress.inspection.class:
    text: Подавить для класса
suppress.inspection.field:
    text: Подавить для поля
suppress.inspection.member:
    text: Подавить для члена
suppress.inspection.method:
    text: Подавить для метода
suppress.inspection.module:
    text: Подавить для объявления модуля
suspected.module.dependency.problem.descriptor:
    text: Модуль «{0}» не зависит от модуля «{1}». Хотя «{1}» не был проинспектирован на предмет экспортируемых зависимостей, необходимых для области «{2}»
suspicious.invocation.handler.implementation.display.name:
    text: Подозрительная реализация InvocationHandler
suspicious.invocation.handler.implementation.method.unused.message:
    text: 'Метод никогда не используется в «invoke»: маловероятно, что «hashCode», «equals» и «toString» реализованы корректно'
suspicious.invocation.handler.implementation.null.returned.for.toString.message:
    text: 'Null может быть возвращён при проксировании метода «toString()»: это не рекомендуется'
suspicious.invocation.handler.implementation.null.returned.message:
    text: 'Null может быть возвращён при проксировании метода «{0}()»: это может вызвать NullPointerException'
suspicious.invocation.handler.implementation.type.mismatch.message:
    text: 'Несовместимый тип может быть возвращен при проксировании метода «{0}()»: требуется: {1}; получено: {2}'
text.raw.ctor.reference.with.type.parameters:
    text: Необработанная ссылка на конструктор с явными параметрами типа для конструктора
text.shebang.mechanism.in.java.files.not.permitted:
    text: Механизм shebang в файлах .java не разрешён
text.unused.import.in.template:
    text: Ненужный импорт (указан в шаблоне)
type.constraint.assignability.explanation.definitely.inconvertible:
    text: '{0} заведомо является {1}, что абсолютно несовместимо с {2}'
type.constraint.assignability.explanation.exact:
    text: '{0} уже известно, что является {1}'
type.constraint.assignability.explanation.exact.not.subtype:
    text: 'Тип {0} точно соответствует {1}, что не является подтипом {2}'
type.constraint.assignability.explanation.exact.subtype:
    text: 'Тип {0} точно соответствует {1}, что является подтипом {2}'
type.constraint.assignability.explanation.not.instance.of:
    text: '{0} заведомо не является {1}'
type.constraint.assignability.explanation.not.instance.of.supertype:
    text: '{0} заведомо не является {1}, что является супер-типом {2}'
type.constraint.assignability.explanation.subtype.of.subtype:
    text: '{0} уже известно, что является {1}, что является подтипом {2}'
type.information.local.object:
    text: локальный объект
type.mismatch.reason:
    text: 'причина: {0}'
type.presentation.except.values:
    text: '{0}, не в {1}'
unknown.guardedby.reference.0.loc:
    text: 'Неизвестная ссылка @GuardedBy «{0}» #loc'
unknown.guardedby.reference.ref.loc:
    text: 'Неизвестная ссылка @GuardedBy #ref #loc'
unnecessary.module.dependency.display.name:
    text: Ненужная зависимость модуля
unnecessary.module.dependency.problem.descriptor:
    text: Исходники модуля «{0}» не зависят от исходников модуля «{1}»
unused.import.display.name:
    text: Ненужный импорт
unused.import.statement:
    text: Ненужное объявление импорта
unused.library.display.name:
    text: Ненужная библиотека
unused.library.problem.descriptor:
    text: Ненужная библиотека «{0}»
unused.library.roots.problem.descriptor:
    text: Ненужные корни {0} из библиотеки «{1}»
var.can.be.replaced.with.explicit.type:
    text: '«var» можно заменить на явный тип'
vararg.method.call.with.50.poly.arguments:
    text: Вызов метода vararg с 50+ аргументами может замедлить компиляцию и анализ
visible.for.testing.makes.little.sense.on.test.only.code:
    text: '@VisibleForTesting имеет мало смысла для кода, помеченного как @TestOnly'
